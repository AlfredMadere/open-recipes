# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2023-10-24T00:41:23+00:00

from __future__ import annotations

from typing import List, Union
from sqlalchemy import exc


from fastapi import FastAPI, Form, HTTPException, Query, Request
from typing import Annotated, Optional
from sqlalchemy.engine import Engine
from fastapi import Depends, FastAPI, HTTPException, status

from fastapi import Depends
from open_recipes.models import Ingredient, Recipe, RecipeList, Review, User, PopulatedRecipe, CreateUserRequest, CreateRecipeListRequest, CreateRecipeRequest, RecipeListResponse, Tag, CreateTagRequest
from open_recipes.database import get_engine 
from sqlalchemy import text, func, distinct, case
import sqlalchemy
import uvicorn
from pydantic import BaseModel
from open_recipes.api.users import router as user_router
from open_recipes.api.recipes import router as recipe_router 
from open_recipes.api.ingredients import router as ingredient_router
from open_recipes.api.tags import router as tag_router
from fastapi.security import OAuth2PasswordBearer
from datetime import datetime, timedelta
from typing import Optional
from models import User, UserInDB, SignUpRequest
from passlib.context import CryptContext
from jose import JWTError, jwt

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm



pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


# class User(BaseModel):
#     username: str
#     email: str | None = None
#     full_name: str | None = None
#     disabled: bool | None = None


# class UserInDB(User):
#     hashed_password: str



app = FastAPI(
    title='Recipe Service API',
    version='1.0.0',
    description='API for managing recipes, ingredients, users, and reviews.',
)

app.include_router(user_router)
app.include_router(recipe_router)
app.include_router(ingredient_router)
app.include_router(tag_router)



SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

# Dependency to get the current user from the token
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


def get_user(username: str):
    engine = get_engine()
    with engine.connect() as conn:
        result = conn.execute(text("""SELECT email, phone, name, id, hashed_password FROM "user" WHERE email = :username"""), {"username": username})
        user_record = result.fetchone()
        if user_record:
            # Assuming the record is a RowProxy, which acts like a dict
            email, phone, name, id, hashed_password = user_record
            return UserInDB(email=email, phone=phone, name=name, hashed_password=hashed_password, id=id)
        return None


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = get_user( username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)]
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    user: UserInDB = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/sign-up", status_code=201)
def create_user(sign_up_data: SignUpRequest, engine : Annotated[Engine, Depends(get_engine)]):
    # Hash the password
    hashed_password = pwd_context.hash(sign_up_data.password)

    # Connect to the database and insert the new user
    with engine.begin() as conn:
        # Adjust the SQL query to match your database schema
        query = text("""
            INSERT INTO "user" (email, name, phone, hashed_password)
            VALUES (:email, :name, :phone, :hashed_password)
            RETURNING id
        """)
        result = conn.execute(query, {
            "email": sign_up_data.email,
            "name": sign_up_data.name,
            "phone": sign_up_data.phone,
            "hashed_password": hashed_password
        })

        return {"message": "User created successfully", "id": result.fetchone()[0]}

@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)]
):
    return current_user


@app.get("/")
def read_root(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"Hello": "World",
            "token": token
            }

#SMOKE TESTED
@app.get('/recipe-lists', response_model=List[RecipeList])
def get_recipe_lists(engine : Annotated[Engine, Depends(get_engine)]) -> List[RecipeList]:
    """
    Get all recipe lists
    """
    recipeListAll = []
    with engine.begin() as conn:
        result = conn.execute(text(f"SELECT id, name, description FROM recipe_list ORDER BY id"))
        rows = result.fetchall()
        for row in rows: 
            id, name, description = row
            recipe = RecipeList(id=id, name=name, description=description)
            recipeListAll.append(recipe)
        return recipeListAll
@app.post(
    '/recipe-lists', response_model=None, status_code=201, responses={'201': {'model': RecipeList}}
)
def post_recipe_lists(body: CreateRecipeListRequest,engine : Annotated[Engine, Depends(get_engine)]) -> Union[None, RecipeList]:
    """
    Create a new recipe list
    """
    try:
        with engine.begin() as conn:
            result = conn.execute(text(f"""INSERT INTO recipe_list (name, description)
                                        VALUES (:name, :description)
                                        RETURNING id, name, description 
                                    """
                                        ),{"name":body.name,"description":body.description})
            
            id, name, description= result.fetchone()
            print(id, name, description)
            return RecipeList(id=id, name=name, description=description)
    except exc.SQLAlchemyError as e:
        raise HTTPException(status_code=500, detail="Database error "  + e._message())
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/recipe-lists/{recipe_list_id}/recipe/{recipe_id}',status_code=201, response_model=Recipe)
def post_recipe_to_list(recipe_id: int, recipe_list_id: int,engine : Annotated[Engine, Depends(get_engine)]) -> Recipe:
    """
    Add a recipe to a recipe list
    """
    try:
        with engine.begin() as conn:
            result = conn.execute(text(f"""INSERT INTO recipe_x_recipe_list (recipe_id, recipe_list_id)
                                        VALUES (:recipe_id, :recipe_list_id)
                                        RETURNING recipe_id, recipe_list_id 
                                    """
                                        ),{"recipe_id":recipe_id,"recipe_list_id":recipe_list_id})
            
            recipe_id, recipe_list_id = result.fetchone()
            return Recipe(recipe_id=recipe_id, recipe_list_id=recipe_list_id)
    except exc.SQLAlchemyError as e:
        raise HTTPException(status_code=500, detail="Database error "  + e._message())
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


#SMOKE TESTED
@app.get('/recipe-lists/{id}', response_model=RecipeListResponse)
def get_recipe_list(id: int,engine : Annotated[Engine, Depends(get_engine)]) -> RecipeList:
    """
    Get a recipe list by id
    """
    with engine.begin() as conn:
        result = conn.execute(text(f"""SELECT id, name, description FROM recipe_list WHERE id = :recipe_id"""),{"recipe_id": id})
        id, name, description = result.fetchone()
        result = conn.execute(text(f"""SELECT id, name, description, mins_prep, mins_cook, default_servings, author_id, procedure
                                        FROM recipe
                                        JOIN recipe_x_recipe_list AS rl ON rl.recipe_id = recipe.id
                                        WHERE rl.recipe_list_id = :list_id"""),{"list_id": id})
        rows = result.fetchall()
        recipes = [Recipe(id=row.id, name=row.name, description=row.description, mins_prep=row.mins_prep, mins_cook=row.mins_cook, default_servings=row.default_servings, author_id=row.author_id, procedure=row.procedure) for row in rows]
        #print(recipes)
        return RecipeListResponse(id=id, name=name, description= description, recipes=recipes)

# @app.post("/recipe-lists/{id}")
# def update_recipe_list(id: int, recipe_list : RecipeList, engine : Annotated[Engine, Depends(get_engine)]) -> RecipeList:
#     with engine.begin() as conn:
#         result = conn.execute(text(f"""UPDATE recipe_list 
#                                    SET name = :name, description = :description
#                                    WHERE id = :id""",{"name":recipe_list.name, "description":recipe_list.description, "id":id}))
#         id, name, description = result.fetchone()
#         return RecipeList(id=id, name=name, description=description)

# @app.delete("/recipe-lists/{id}")
# def delete_recipe_list(id: int,engine : Annotated[Engine, Depends(get_engine)]) -> None:
#     with engine.begin() as conn:
#         result = conn.execute(text(f"""DELETE FROM recipe_list 
#                                    WHER
#                                    default_servings, procedure FROM "recipe" """))
#         id, name, mins_prep, category_id, mins_cook, description, author_id, default_servings, procedure = result.fetchone()
#         return Recipe(id=id, name=name, mins_prep=mins_prep, category_id=category_id, mins_cook=mins_cook, description=description, author_id=author_id, default_servings=default_servings, procedure=procedure)
 


class SearchResults(BaseModel):
    recipe: List[Recipe]
    next_cursor: Optional[int]
    prev_cursor: Optional[int]
    
# @app.get('/reviews', response_model=List[Review])
# def get_reviews(engine : Annotated[Engine, Depends(get_engine)]) -> List[Review]:
#     """
#     Get all reviews
#     """
#     with engine.begin() as conn:
#         result = conn.execute(text(f"SELECT id, stars, author_id, content, recipe_id, FROM reviews ORDER BY created_at"))
#         id, name, email, phone = result.fetchone()
#         return User(id=id, name=name, email=email, phone=phone)

# @app.post('/reviews', response_model=None, responses={'201': {'model': Review}})
# def post_reviews(body: Review,engine : Annotated[Engine, Depends(get_engine)]) -> Union[None, Review]:
#     """
#     Create a new review
#     """
#     with engine.begin() as conn:
#         result = conn.execute(text(f"INSERT INTO reviews stars, author_id, content, recipe_id values (:stars,:author_id,:content,:recipe_id)",{"stars":body.stars,"author_id":body.author.id,"content":body.content,"recipe_id":body.recepie.id}))
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return User(id=id, stars=stars, author_id=author_id, content=content, recipe_id = recipe_id)

# @app.get('/reviews/{id}', response_model=Review)
# def get_review(id: int,engine : Annotated[Engine, Depends(get_engine)]) -> Review:
#     """
#     Get a review by id
#     """
#     with engine.begin() as conn:
#         result = conn.execute(text(f"""SELECT stars, author_id, content, recipe_id FROM review WHERE id = :id"""),{"id":id})
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return Review(id=id, stars=stars, author_id=author_id, content=content, recipe_id = recipe_id)

# @app.post("/reviews/{id}")
# def update_review(id: int, review : Review,engine : Annotated[Engine, Depends(get_engine)]) -> Review:
#     with engine.begin() as conn:
#         result = conn.execute(text(f"UPDATE review SET stars = :stars, author_id = :author_id, content = :content, recipe_id = :recipe_id WHERE id = :id",{"stars":review.stars,"author_id":review.author_id, "content":review.content,  "recipe_id":review.recipe_id, "id":id}))
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return Review(id=id, stars = stars, author_id = author_id, content = content, recipe_id = recipe_id)

# @app.delete("/reviews/{id}")
# def delete_review(id: int,engine : Annotated[Engine, Depends(get_engine)]) -> None:
#     with engine.begin() as conn:
#         result = conn.execute(text(f"""DELETE FROM "reviews" WHERE id = :id""",{"id":id}))
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return Review(id=id, stars=stars, author_id=author_id, content=content, recipe_id = recipe_id)


@app.post('/test-post')
async def test_post(request: Request):
    # Access query parameters from the URL
    query_params = dict(request.query_params)

    # Access data from the request body (assuming it's JSON)
    try:
        data = await request.json()
    except ValueError:
        data = None  # Set data to None if no JSON data is sent

    # Prepare the response data
    response_data = {
        'request_data': data,
        'query_parameters': query_params,
    }

    return response_data



if __name__ == "__main__":
    import uvicorn

    config = uvicorn.Config(
        app, port=3000, log_level="info", reload=True
    )
    server = uvicorn.Server(config)
    server.run()
