# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2023-10-24T00:41:23+00:00

from __future__ import annotations

from typing import List, Union
from sqlalchemy import exc


from fastapi import FastAPI, Form, HTTPException, Query, Request
from typing import Annotated, Optional
from sqlalchemy.engine import Engine
from fastapi import Depends, FastAPI, HTTPException, status

from fastapi import Depends
from open_recipes.models import Ingredient, Recipe, RecipeList, Review, User, PopulatedRecipe, CreateUserRequest, CreateRecipeListRequest, CreateRecipeRequest, RecipeListResponse, Tag, CreateTagRequest
from open_recipes.database import get_engine 
from sqlalchemy import text, func, distinct, case
import sqlalchemy
import uvicorn
from pydantic import BaseModel
from open_recipes.api.users import router as user_router
from open_recipes.api.recipes import router as recipe_router 
from open_recipes.api.ingredients import router as ingredient_router
from open_recipes.api.tags import router as tag_router
from fastapi.security import OAuth2PasswordBearer
from datetime import datetime, timedelta
from typing import Optional
from models import User, UserInDB, SignUpRequest
from passlib.context import CryptContext
from jose import JWTError, jwt
from api.auth import oauth2_scheme, create_access_token, get_current_active_user
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from api.auth import router as auth_router
from api.recipe_lists import router as recipe_list_router





# class User(BaseModel):
#     username: str
#     email: str | None = None
#     full_name: str | None = None
#     disabled: bool | None = None


# class UserInDB(User):
#     hashed_password: str



app = FastAPI(
    title='Recipe Service API',
    version='1.0.0',
    description='API for managing recipes, ingredients, users, and reviews.',
)

app.include_router(user_router)
app.include_router(recipe_router)
app.include_router(ingredient_router)
app.include_router(tag_router)
app.include_router(
    auth_router,
)
app.include_router(
    recipe_list_router
)





@app.get("/")
def read_root(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"Hello": "World",
            "token": token
            }

#SMOKE TESTED


class SearchResults(BaseModel):
    recipe: List[Recipe]
    next_cursor: Optional[int]
    prev_cursor: Optional[int]
    
# @app.get('/reviews', response_model=List[Review])
# def get_reviews(engine : Annotated[Engine, Depends(get_engine)]) -> List[Review]:
#     """
#     Get all reviews
#     """
#     with engine.begin() as conn:
#         result = conn.execute(text(f"SELECT id, stars, author_id, content, recipe_id, FROM reviews ORDER BY created_at"))
#         id, name, email, phone = result.fetchone()
#         return User(id=id, name=name, email=email, phone=phone)

# @app.post('/reviews', response_model=None, responses={'201': {'model': Review}})
# def post_reviews(body: Review,engine : Annotated[Engine, Depends(get_engine)]) -> Union[None, Review]:
#     """
#     Create a new review
#     """
#     with engine.begin() as conn:
#         result = conn.execute(text(f"INSERT INTO reviews stars, author_id, content, recipe_id values (:stars,:author_id,:content,:recipe_id)",{"stars":body.stars,"author_id":body.author.id,"content":body.content,"recipe_id":body.recepie.id}))
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return User(id=id, stars=stars, author_id=author_id, content=content, recipe_id = recipe_id)

# @app.get('/reviews/{id}', response_model=Review)
# def get_review(id: int,engine : Annotated[Engine, Depends(get_engine)]) -> Review:
#     """
#     Get a review by id
#     """
#     with engine.begin() as conn:
#         result = conn.execute(text(f"""SELECT stars, author_id, content, recipe_id FROM review WHERE id = :id"""),{"id":id})
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return Review(id=id, stars=stars, author_id=author_id, content=content, recipe_id = recipe_id)

# @app.post("/reviews/{id}")
# def update_review(id: int, review : Review,engine : Annotated[Engine, Depends(get_engine)]) -> Review:
#     with engine.begin() as conn:
#         result = conn.execute(text(f"UPDATE review SET stars = :stars, author_id = :author_id, content = :content, recipe_id = :recipe_id WHERE id = :id",{"stars":review.stars,"author_id":review.author_id, "content":review.content,  "recipe_id":review.recipe_id, "id":id}))
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return Review(id=id, stars = stars, author_id = author_id, content = content, recipe_id = recipe_id)

# @app.delete("/reviews/{id}")
# def delete_review(id: int,engine : Annotated[Engine, Depends(get_engine)]) -> None:
#     with engine.begin() as conn:
#         result = conn.execute(text(f"""DELETE FROM "reviews" WHERE id = :id""",{"id":id}))
#         id, stars, author_id, content, recipe_id = result.fetchone()
#         return Review(id=id, stars=stars, author_id=author_id, content=content, recipe_id = recipe_id)


@app.post('/test-post')
async def test_post(request: Request):
    # Access query parameters from the URL
    query_params = dict(request.query_params)

    # Access data from the request body (assuming it's JSON)
    try:
        data = await request.json()
    except ValueError:
        data = None  # Set data to None if no JSON data is sent

    # Prepare the response data
    response_data = {
        'request_data': data,
        'query_parameters': query_params,
    }

    return response_data



if __name__ == "__main__":
    import uvicorn

    config = uvicorn.Config(
        app, port=3000, log_level="info", reload=True
    )
    server = uvicorn.Server(config)
    server.run()
